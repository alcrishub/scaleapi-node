/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments";
import * as core from "../../../../core";
import { Scale } from "@fern-api/scale";
import urlJoin from "url-join";
import * as serializers from "../../../../serialization";
import * as errors from "../../../../errors";

export declare namespace Client {
    interface Options {
        environment?: environments.ScaleEnvironment | string;
        token?: core.Supplier<core.BearerToken>;
    }
}

export class Client {
    constructor(private readonly options: Client.Options) {}

    /**
     * List information for all projects. **Note:** No parameters required. Optionally, set a boolean value for `archived` to only list information for all (un)archived projects.
     */
    public async list(request: Scale.ListProjectsRequest = {}): Promise<Scale.Project[]> {
        const { archived } = request;
        const _queryParams = new URLSearchParams();
        if (archived != null) {
            _queryParams.append("archived", archived.toString());
        }

        const _response = await core.fetcher({
            url: urlJoin(this.options.environment ?? environments.ScaleEnvironment.Production, "/projects"),
            method: "GET",
            headers: {
                Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
            },
            queryParameters: _queryParams,
        });
        if (_response.ok) {
            return await serializers.projects.list.Response.parseOrThrow(
                _response.body as serializers.projects.list.Response.Raw,
                { allowUnknownKeys: true }
            );
        }

        if (_response.error.reason === "status-code") {
            throw new errors.ScaleError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScaleError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.ScaleTimeoutError();
            case "unknown":
                throw new errors.ScaleError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     *
     */
    public async create(request: Scale.CreateProjectRequest): Promise<Scale.Project> {
        const _response = await core.fetcher({
            url: urlJoin(this.options.environment ?? environments.ScaleEnvironment.Production, "/projects"),
            method: "POST",
            headers: {
                Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
            },
            body: await serializers.CreateProjectRequest.jsonOrThrow(request),
        });
        if (_response.ok) {
            return await serializers.Project.parseOrThrow(_response.body as serializers.Project.Raw, {
                allowUnknownKeys: true,
            });
        }

        if (_response.error.reason === "status-code") {
            throw new errors.ScaleError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScaleError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.ScaleTimeoutError();
            case "unknown":
                throw new errors.ScaleError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Retrieve information about a single project.
     */
    public async get(name: string): Promise<Scale.Project> {
        const _response = await core.fetcher({
            url: urlJoin(this.options.environment ?? environments.ScaleEnvironment.Production, `/projects/${name}`),
            method: "GET",
            headers: {
                Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
            },
        });
        if (_response.ok) {
            return await serializers.Project.parseOrThrow(_response.body as serializers.Project.Raw, {
                allowUnknownKeys: true,
            });
        }

        if (_response.error.reason === "status-code") {
            throw new errors.ScaleError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScaleError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.ScaleTimeoutError();
            case "unknown":
                throw new errors.ScaleError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * You can set parameters on a project. Project-level-parameters will be set on future tasks created under this project if they are not set in the task request. Any parameters specified in the task request will override any project parameter. Projects keep a history of the parameters that they were set with. Tasks created under a project inherit the latest params of the project (the last entry in param_history), one can also specify project_version when creating a task to inherit from an older set of params (or use -1 to skip parameter inheritance altogether.) Tasks have a `project_param_version` field pointing to the project version in place at the time a task was created. If you haven't already, check out our [guide to using Project-level parameters](/reference/using-project-versioning) to learn more about how this workflow comes togeher. Just want to see some examples? [We've added those as well](/reference/examples-of-project-parameters).
     */
    public async updateParameters(
        name: string,
        request: Scale.UpdateProjectParametersRequest = {}
    ): Promise<Scale.Project> {
        const _response = await core.fetcher({
            url: urlJoin(
                this.options.environment ?? environments.ScaleEnvironment.Production,
                `/projects/${name}/setParams`
            ),
            method: "POST",
            headers: {
                Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
            },
            body: await serializers.UpdateProjectParametersRequest.jsonOrThrow(request),
        });
        if (_response.ok) {
            return await serializers.Project.parseOrThrow(_response.body as serializers.Project.Raw, {
                allowUnknownKeys: true,
            });
        }

        if (_response.error.reason === "status-code") {
            throw new errors.ScaleError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScaleError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.ScaleTimeoutError();
            case "unknown":
                throw new errors.ScaleError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * You can set ontologies on a project. Ontologies will be referenced by the tasks of a project. Projects keep a history of the ontologies they were set with. The ontology can be composed of a list of strings or [OntologyChoice](/reference/ontology-nesting-and-options) objects. Ontology choices and their subchoices must be unique throughout the ontology.
     */
    public async setOntology(name: string, request: Scale.SetOntologyRequest): Promise<void> {
        const _response = await core.fetcher({
            url: urlJoin(
                this.options.environment ?? environments.ScaleEnvironment.Production,
                `/projects/${name}/setOntology`
            ),
            method: "POST",
            headers: {
                Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
            },
            body: await serializers.SetOntologyRequest.jsonOrThrow(request),
        });
        if (_response.ok) {
            return;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.ScaleError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScaleError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.ScaleTimeoutError();
            case "unknown":
                throw new errors.ScaleError({
                    message: _response.error.errorMessage,
                });
        }
    }
}
