/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../../../environments";
import * as core from "../../../../../../core";
import { Scale } from "@fern-api/scale";
import urlJoin from "url-join";
import * as serializers from "../../../../../../serialization";
import * as errors from "../../../../../../errors";

export declare namespace Batches {
    interface Options {
        environment?: environments.ScaleEnvironment | string;
        token?: core.Supplier<core.BearerToken | undefined>;
    }
}

export class Batches {
    constructor(private readonly options: Batches.Options) {}

    /**
     * Returns basic information about all pending batches, in order of priority.
     */
    public async list(): Promise<Scale.studio.Batch[]> {
        const _response = await core.fetcher({
            url: urlJoin(this.options.environment ?? environments.ScaleEnvironment.Production, "/studio/batches"),
            method: "GET",
            headers: {
                Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
            },
        });
        if (_response.ok) {
            return await serializers.studio.batches.list.Response.parseOrThrow(
                _response.body as serializers.studio.batches.list.Response.Raw,
                { allowUnknownKeys: true }
            );
        }

        if (_response.error.reason === "status-code") {
            throw new errors.ScaleError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScaleError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.ScaleTimeoutError();
            case "unknown":
                throw new errors.ScaleError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Sets (not adds to) labeler group assignment for the specified batch. You can add individual members as well by specifying their email as a group name. Returns information only about the specified batch.
     */
    public async setGroups(
        batch: string,
        request: Scale.studio.SetBatchGroupRequest = {}
    ): Promise<Scale.studio.Batch> {
        const _response = await core.fetcher({
            url: urlJoin(
                this.options.environment ?? environments.ScaleEnvironment.Production,
                `/studio/batches/${batch}`
            ),
            method: "PUT",
            headers: {
                Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
            },
            body: await serializers.studio.SetBatchGroupRequest.jsonOrThrow(request),
        });
        if (_response.ok) {
            return await serializers.studio.Batch.parseOrThrow(_response.body as serializers.studio.Batch.Raw, {
                allowUnknownKeys: true,
            });
        }

        if (_response.error.reason === "status-code") {
            throw new errors.ScaleError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScaleError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.ScaleTimeoutError();
            case "unknown":
                throw new errors.ScaleError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Sets the priority of your batches based on the order of your input. The batches field of the body must be an array of objects, each with variable “name”, each representing a pending batch. You can use the response from the batches endpoint to retrieve all pending Studio batches, then rearrange the batches in the returned array. You must include ALL of the pending batches in your request. Returns all batches in new priority order.
     */
    public async setPriorities(request: Scale.studio.SetBatchPrioritiesRequest = {}): Promise<Scale.studio.Batch[]> {
        const _response = await core.fetcher({
            url: urlJoin(
                this.options.environment ?? environments.ScaleEnvironment.Production,
                "/studio/batches/set_priorities"
            ),
            method: "POST",
            headers: {
                Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
            },
            body: await serializers.studio.SetBatchPrioritiesRequest.jsonOrThrow(request),
        });
        if (_response.ok) {
            return await serializers.studio.batches.setPriorities.Response.parseOrThrow(
                _response.body as serializers.studio.batches.setPriorities.Response.Raw,
                { allowUnknownKeys: true }
            );
        }

        if (_response.error.reason === "status-code") {
            throw new errors.ScaleError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScaleError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.ScaleTimeoutError();
            case "unknown":
                throw new errors.ScaleError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Restores batch priority order to default order. Default order is sorted by calibration batches first, then by creation date. Returns all batches in new priority order.
     */
    public async resetPriorities(): Promise<Scale.studio.Batch[]> {
        const _response = await core.fetcher({
            url: urlJoin(
                this.options.environment ?? environments.ScaleEnvironment.Production,
                "/studio/batches/reset_priorities"
            ),
            method: "POST",
            headers: {
                Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
            },
        });
        if (_response.ok) {
            return await serializers.studio.batches.resetPriorities.Response.parseOrThrow(
                _response.body as serializers.studio.batches.resetPriorities.Response.Raw,
                { allowUnknownKeys: true }
            );
        }

        if (_response.error.reason === "status-code") {
            throw new errors.ScaleError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScaleError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.ScaleTimeoutError();
            case "unknown":
                throw new errors.ScaleError({
                    message: _response.error.errorMessage,
                });
        }
    }
}
